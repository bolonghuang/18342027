###我的第三次作业

##Part one

#Write out variables x,y and z in binary code

1)int8_t x =67;int8_t y=-7;int8_t z=y-z;
x = 01000011B;y = 11111001B;z = 10110110B;

2)int8_t x = oxd3;
x = 11010011B;

3)uint8_t x= oxd3;
x = 11010011B;

4)int8_t x = 127;int8_t y = -7;int8_t z = y-x;
x = 01111111B;y = 11111001B;z = 01111010B;

5)float x = 1.125;
x = 00000001.001B;

6)float x = 23.0;
x = 00010111.0B;

7)float x = 0.45;
x = 0.0111001100~B;

overflow :2)int8_t x = oxd3;4)int8_t z = y-x;
Accuracy error ：7)float x = 0.45;

##Part two

1)Method of complements 
In mathematics and computing, the method of 
complements is a technique used to subtract one 
number from another using only addition of positive 
numbers. This method was commonly used in mechanical
 calculators and is still used in modern computers.

2)Byte 
The byte is a unit of digital information that most commonly
consists of eight bits, representing a binary number.
Historically, the byte was the number of bits used to encode
a single character of text in a computer[1][2] and for this 
reason it is the smallest addressable unit of memory in many 
computer architectures. 

3)Integer (computer science)
to search
In computer science, an integer is a datum of integral data type,
a data type that represents some range of mathematical integers. 

4)Floating point
In computing, floating-point arithmetic (FP) is arithmetic using
formulaic representation of real numbers as an approximation so
as to support a trade-off between range and precision. 

##part three

证明

由公式可知，N[I]=2k-I.
又N[I]=2k-I=[(2k-1)-I]+1=[(2-1)×2k-1+(2-1)×2k-2+...+(2-1)×2+(2-1)×1-(bk×2k-1+bk-1×2k-2+...b2×k+b1)]+1
整理可得：
N[I]=[(1-bk)×2k-1+(1-bk-1)×2k-2+...+(1-b2)×2+(1-b1)]+1
又在二进制中，bi=0或bi=1. 当bi=0时,1-bi=1；当bi=1时,1-bi=0。
综上可得，二进制的负数（two‘s complement of X）等于 X 的 ones’ complement ＋ 1（X每位求反加1）。

Int8_t x = - 017; 请用8进制描述变量 x。
x=(-15)10=(11110001)2=(361)8
x用8进制表示为(361)8。
##证明 ## 1)C程序：int8_t x = -0x1f;  int y = x;  请用16进制描述变量 x 和 y，并说明 int y = x 的计算过程。
x=(-31)10=(11100001)2=(E1)16
y=(11111111111111111111111111100001)2=(FFFFFFE1)16
将一个字节的x赋值给四个字节的y，因为x是负值，而扩展一个负数的时候需要在保留原值的基础上将扩展的高位全赋为1，因而y变为（11111111111111111111111111100001)2。
2)请用数学证明，为什么可以这么计算。
由之前的证明即
N[I]=2k-I.
又N[I]=2k-I=[(2k-1)-I]+1=[(2-1)×2k-1+(2-1)×2k-2+...+(2-1)×2+(2-1)×1-(bk×2k-1+bk-1×2k-2+...b2×k+b1)]+1
整理可得：
N[I]=[(1-bk)×2k-1+(1-bk-1)×2k-2+...+(1-b2)×2+(1-b1)]+1
又在二进制中，bi=0或bi=1. 当bi=0时,1-bi=1；当bi=1时,1-bi=0。
可知，二进制的负数等于该数各位取反再加一。
假设y从第x+1位到第n位为扩展的高位，从第1位到第x位是原值。
y=bn×2n-1+bn-1×2n-2+....+bx×2x-1+...+b2×2+b1
又从第x+1位到第n位均为1，取反后均为0
所以y=bx×2x-1+...+b2×2+b1
而剩下的原值取反加1显然即为对应的正数，这一点也显然已有上式证得。
因此将负数的扩展为取1不会影响该数的大小。
NaN 是什么？##
IEEE 754 specifies a special value called "Not a Number" (NaN) to be returned as the result of certain "invalid" operations, such as 0/0, ∞×0, or sqrt(−1).
在浮点数运算中，NaN与无穷大的概念不同，尽管两者均是以浮点数表示实数时的特殊值。无效操作（Invalid Operation）同样也不同于算术溢出（可能返回无穷大）和算术下溢出（可能返回最小的一般数值、特殊数值、零等）。
IEEE 754-1985中，用指数部分全为1、小数部分非零表示NaN。以32位IEEE单精度浮点数的NaN为例，按位表示即：S111 1111 1AXX XXXX XXXX XXXX XXXX XXXX，S为符号位，符号位S的取值无关紧要；A是小数部分的最高位（ the most significant bit of the significand），其取值表示了NaN的类型：X不能全为0，并被称为NaN的payload。
返回NaN的运算有如下三种：
至少有一个参数是NaN的运算
下列除法运算：0/0、∞/∞、∞/−∞、−∞/∞、−∞/−∞
下列乘法运算：0×∞、0×−∞
下列加法运算：∞ + (−∞)、(−∞) + ∞
下列减法运算：∞ - ∞、(−∞) - (−∞)
产生复数结果的实数运算，例如：
对负数进行开偶次方的运算
对负数进行对数运算
对正弦或余弦到达域以外的数进行反正弦或反余弦运算


